---
title: "HW2 Imp"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Q3: 

A statistical issue in the use of the hierarchical model developed in Assignment 2 – Background is the fixed value of the power $\theta = 1.0$ used in the analysis. Describe how you would conduct an assessment of this modeling choice. In particular, there are two immediate alternatives to our choice. One is that a single value of $\theta$ should be adequate to reflect data behavior, but its value should be something other than $\theta = 1.0$. In this case, we might assign a prior (similarly to $\alpha$), but this question is not about what we might choose for that prior, only how we might assess the output of analysis of the hierarchical model in files `LMBmcmc1.txt` and `LMBmcmc2.txt` and the actual data (in file `LMBdat_for601.txt`) to determine whether we are motivated to include a prior for $\theta$. 

The other possibility is that we might allow this power to have different values in different lakes, and make use of parameters $\{\theta_i : i = 1, \ldots, n\}$. These quantities would then need to be assigned a distribution, the parameters of which will be assigned a prior but, again, don’t worry about what any of those distributions might be, only how we could determine whether there is evidence that a single value of $\theta$, be that $\theta = 1$ or some other value, appears adequate or inadequate to reflect the behavior of the actual data.

## Answer

The parameter $\theta$ determines how variance scales with the mean through

$$
\operatorname{Var}(Y_{i,j}\mid \cdot) = \sigma_i^2 \mu_{i,j}^{2\theta},
$$

so fixing $\theta=1$ imposes the specific relationship $\operatorname{Var}(Y_{i,j}) \propto \mu_{i,j}^2$. To assess whether this assumption is adequate, I used the posterior draws from the existing hierarchical fit together with the observed data to evaluate residual behavior and directly estimate the implied scaling exponent.

### Diagnostic procedure

Using posterior draws of $\mu_{i,j}$ and $\sigma_i^2$, I computed standardized residuals

$$
r_{i,j}^{(1)}=\frac{y_{i,j}-\mu_{i,j}}{\sigma_i \mu_{i,j}},
$$

which should resemble iid $N(0,1)$ if $\theta=1$ is correct. I examined:

- residuals vs.\ $\hat{\mu}_{i,j}$,
- $|r_{i,j}^{(1)}|$ vs.\ $\hat{\mu}_{i,j}$,
- normal Q–Q plots,
- and log–variance regressions

$$
\log\!\left(\frac{(y_{i,j}-\mu_{i,j})^2}{\sigma_i^2}\right)
= c + 2\theta \log(\mu_{i,j}) + \varepsilon,
$$

fitting these both pooled across lakes and separately within each lake. The regression slope provides an estimate of $2\theta$.

### Results

The residual diagnostics show clear violations of the $\theta=1$ assumption. The standardized residual plots exhibit a funnel shape, with residual spread changing systematically with $\hat{\mu}_{i,j}$, indicating remaining heteroscedasticity. Q–Q plots show strong right tails and outliers, inconsistent with approximate normality.

The pooled log–variance regression across posterior draws gives

$$
\theta \approx 0.924,
\qquad
95\% \text{ credible interval } [0.909,\,0.948],
$$

which excludes $1$. Thus, the data provide strong evidence that the common scaling exponent differs from $\theta=1$.

Lake-specific regressions reveal some heterogeneity in $\theta_i$, but most lakes’ credible intervals overlap $1$ and cluster near the pooled estimate, suggesting only moderate between-lake variability rather than dramatic differences.

### Conclusions

These diagnostics indicate that fixing $\theta=1$ is not adequate.

1. **Single common $\theta$:**  
   There is strong evidence that a common but unknown $\theta \neq 1$ better describes the mean–variance relationship. This motivates treating $\theta$ as an estimable parameter with a prior.

2. **Lake-specific $\theta_i$:**  
   While some heterogeneity is present, it appears modest. Allowing $\theta_i$ to vary by lake may provide additional flexibility, but the evidence for this extension is weaker than for estimating a single global $\theta$.

Overall, the data strongly support replacing the fixed value $\theta=1$ with an estimated common exponent, with lake-specific exponents considered only if additional flexibility is scientifically justified.

\newpage 

# Appendix 

```{r, cache = T, echo = F}
## Q3 diagnostics (revised): theta = 1 adequacy + clearer, more informative outputs
## Key changes:
##  - keep posterior-mean summaries together, then QQ plots together (as you liked)
##  - make pooled-theta output more informative (mean + CI + density/hist + reference line at 1)
##  - make lake-specific output interpretable (attach lknum, n_i, CI, include-1 flag, sorted caterpillar)
##  - avoid the confusing "flag = almost everything" by using a 95% interval (or adjustable)

dat <- read.table("LMBdat_for601.txt", header = TRUE)
m1  <- read.table("LMBmcmc1.txt", header = TRUE)
m2  <- as.matrix(read.table("LMBmcmc2.txt", header = TRUE))

## --- 1) Parse posterior draws ---
n_lakes <- 75
stopifnot(ncol(m2) >= 2*n_lakes + 1)

beta_draws  <- m2[, 1:n_lakes, drop = FALSE]
sig2_draws  <- m2[, (n_lakes + 1):(2*n_lakes), drop = FALSE]
alpha_draws <- m2[, 2*n_lakes + 1]   # alpha column
## theta exists but is fixed at 1 in the provided fit

## --- 2) Map lake labels to 1..n_lakes (matches MCMC column ordering) ---
stopifnot(all(c("lknum","len","wt") %in% names(dat)))
stopifnot(!anyNA(dat$lknum))

lake_levels <- sort(unique(dat$lknum))
stopifnot(length(lake_levels) == n_lakes)

dat$lake_id <- match(dat$lknum, lake_levels)
stopifnot(all(dat$lake_id %in% 1:n_lakes))

N     <- nrow(dat)
y_vec <- dat$wt

## counts per lake (useful for interpreting lake-level diagnostics)
n_i <- as.integer(table(factor(dat$lake_id, levels = 1:n_lakes)))

## --- 3) Subsample posterior draws for speed ---
set.seed(1)
S   <- min(400, nrow(m2))
idx <- sample(seq_len(nrow(m2)), S)

beta_s  <- beta_draws[idx, , drop = FALSE]
sig2_s  <- sig2_draws[idx, , drop = FALSE]
alpha_s <- alpha_draws[idx]

## --- 4) Compute mu_{ij}^{(s)} and sigma_i^{2(s)} for each observation ---
mu_mat   <- matrix(NA_real_, nrow = S, ncol = N)
sig2_mat <- matrix(NA_real_, nrow = S, ncol = N)

for (s in seq_len(S)) {
  a_s <- alpha_s[s]
  b_vec   <- beta_s[s, dat$lake_id]
  sg2_vec <- sig2_s[s, dat$lake_id]
  mu_mat[s, ]   <- b_vec * (dat$len ^ a_s)
  sig2_mat[s, ] <- sg2_vec
}

sig_mat <- sqrt(sig2_mat)

## Posterior means (group these summaries together, per your preference)
mu_hat   <- colMeans(mu_mat)
sig2_hat <- colMeans(sig2_mat)

## --- 5) Residual diagnostics under theta = 1, with posterior uncertainty ---
## draw-level standardized residuals: r_{ij}^{(s)} = (y - mu^{(s)})/(sigma^{(s)} * mu^{(s)})
r_mat <- (matrix(y_vec, nrow = S, ncol = N, byrow = TRUE) - mu_mat) / (sig_mat * mu_mat)

## posterior mean residual and posterior mean absolute residual per observation
rbar     <- colMeans(r_mat)
abs_rbar <- colMeans(abs(r_mat))

## --- 6) Pooled theta diagnostic with posterior uncertainty (more detailed output) ---
## For each draw s:
## y*_ij(s) = log( (y - mu(s))^2 / sig2(s) ), x*_ij(s) = log(mu(s)), slope = 2*theta(s)
eps <- 1e-12
theta_s <- rep(NA_real_, S)

for (s in seq_len(S)) {
  res_s    <- y_vec - mu_mat[s, ]
  y_star_s <- log((res_s^2 + eps) / (sig2_mat[s, ] + eps))
  x_star_s <- log(mu_mat[s, ] + eps)
  fit_s    <- lm(y_star_s ~ x_star_s)
  theta_s[s] <- coef(fit_s)[2] / 2
}

theta_mean <- mean(theta_s, na.rm = TRUE)
theta_q    <- quantile(theta_s, probs = c(0.025, 0.50, 0.975), na.rm = TRUE)

cat("\nPooled theta diagnostic (from draw-level log-variance slopes):\n")
cat(sprintf("  posterior mean(theta):  %.4f\n", theta_mean))
cat(sprintf("  posterior median(theta): %.4f\n", theta_q[[2]]))
cat(sprintf("  95%% interval(theta):    [%.4f, %.4f]\n\n", theta_q[[1]], theta_q[[3]]))

## --- 7) Lake-by-lake theta_i diagnostics (with clearer summary + plot) ---
theta_lake_s <- matrix(NA_real_, nrow = S, ncol = n_lakes)

for (s in seq_len(S)) {
  res_s    <- y_vec - mu_mat[s, ]
  y_star_s <- log((res_s^2 + eps) / (sig2_mat[s, ] + eps))
  x_star_s <- log(mu_mat[s, ] + eps)

  for (i in seq_len(n_lakes)) {
    ii <- which(dat$lake_id == i)
    ## require a minimum sample size for a stable slope
    if (length(ii) < 10) next
    fit_i <- lm(y_star_s[ii] ~ x_star_s[ii])
    theta_lake_s[s, i] <- coef(fit_i)[2] / 2
  }
}

theta_lake_mean <- colMeans(theta_lake_s, na.rm = TRUE)
theta_lake_lo   <- apply(theta_lake_s, 2, quantile, probs = 0.025, na.rm = TRUE)
theta_lake_hi   <- apply(theta_lake_s, 2, quantile, probs = 0.975, na.rm = TRUE)

## keep an interpretable table: lake_id, lknum label, n_i, mean theta_i, CI, include-1 indicator
lake_tbl <- data.frame(
  lake_id   = 1:n_lakes,
  lknum     = lake_levels,
  n_obs     = n_i,
  theta_mean = theta_lake_mean,
  theta_lo   = theta_lake_lo,
  theta_hi   = theta_lake_hi
)

lake_tbl$ci_includes_1 <- with(lake_tbl, (theta_lo <= 1) & (theta_hi >= 1))
lake_tbl$abs_dev_from_1 <- abs(lake_tbl$theta_mean - 1)

## Print the most informative rows (instead of a huge confusing flag vector)
lake_tbl_sorted <- lake_tbl[order(-lake_tbl$abs_dev_from_1), ]

# cat("Most deviant lakes by |E(theta_i|y) - 1| (top 12):\n")
# print(lake_tbl_sorted[1:12, c("lake_id","lknum","n_obs","theta_mean","theta_lo","theta_hi","ci_includes_1")],
#       row.names = FALSE)

# cat("\nLakes whose 95% interval for theta_i excludes 1 (if any):\n")
# excl <- which(!lake_tbl$ci_includes_1 & !is.na(lake_tbl$theta_lo) & !is.na(lake_tbl$theta_hi))
# if (length(excl) == 0) {
#   cat("  (none)\n\n")
# } else {
#   print(lake_tbl[excl, c("lake_id","lknum","n_obs","theta_mean","theta_lo","theta_hi")], row.names = FALSE)
#   cat("\n")
# }

## --- Plots (grouped more cleanly) ---

## A) Posterior-mean residual summaries (2 panels)
par(mfrow = c(1, 2))

plot(mu_hat, rbar,
     xlab = expression(hat(mu)[i,j]),
     ylab = expression("E[r_{i,j} | y]"),
     main = expression("Std residuals (theta = 1): posterior mean"))
abline(h = 0, lty = 2)
lines(lowess(mu_hat, rbar), lwd = 2)

plot(mu_hat, abs_rbar,
     xlab = expression(hat(mu)[i,j]),
     ylab = expression("E[|r_{i,j}| | y]"),
     main = expression("|Std residual| (theta = 1): posterior mean"))
lines(lowess(mu_hat, abs_rbar), lwd = 2)

par(mfrow = c(1, 1))

## B) QQ plots together (2 panels)
par(mfrow = c(1, 2))

qqnorm(rbar, main = "Q-Q: posterior mean std residuals")
qqline(rbar)

set.seed(2)
take <- sample.int(S * N, size = min(50000, S * N))
qqnorm(r_mat[take], main = "Q-Q: draw-level std residuals (subsample)")
qqline(r_mat[take])

par(mfrow = c(1, 1))

## C) Pooled theta distribution (clearer than just printing a number)
hist(theta_s, breaks = 30,
     main = expression("Pooled " * theta * " diagnostic (draw-level slopes)"),
     xlab = expression(theta))
abline(v = 1, lty = 2, lwd = 2)
abline(v = theta_q, lty = c(3,1,3), lwd = 2)

## D) Lake-specific theta_i caterpillar plot (sorted; flagged clearly)
ord <- order(lake_tbl$theta_mean, na.last = NA)
lake_tbl_ord <- lake_tbl[ord, ]

xpos <- seq_len(nrow(lake_tbl_ord))
pch_vec <- ifelse(lake_tbl_ord$ci_includes_1, 1, 19)

plot(xpos, lake_tbl_ord$theta_mean,
     pch = pch_vec,
     xlab = "Lakes (sorted by E(theta_i|y))",
     ylab = expression("E[" * theta[i] * " | y]"),
     main = expression("Lake-specific " * theta[i] * " diagnostic (95% intervals)"),
     xaxt = "n")
segments(x0 = xpos, y0 = lake_tbl_ord$theta_lo,
         x1 = xpos, y1 = lake_tbl_ord$theta_hi)
abline(h = 1, lty = 2)

legend("topright",
       legend = c("95% interval includes 1", "95% interval excludes 1"),
       pch = c(1, 19), bty = "n")
```