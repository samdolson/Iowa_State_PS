---
title: "HW5"
output:
  pdf_document: default
  html_document: default
  word_document: default
date: "2024-09-29"
---

# Status 
  - Q1: WIP
  - Q2: DONE
  - Q3: WIP
  - Q4: DONE
  - Q5: DONE 
  - Q6: DONE 
  - Q7: DONE 

# Homework 5
Due October 15 

## Q1 
> Q: 

Use the state.x77 data matrix and the tapply(), and separately, the aggregate() function to obtain

>> a. 

The mean per capita income of the states in each of the four regions defined by the factor state.region,

>> b.

The maximum illiteracy rates for states in each of the nine divisions defined by the factor state.division,

>> c. 

The number of states in each region,

>> d.

The names of the states in each division,

>> e. 

The median high school graduation rates for groups of states defined by combinations of the factors
state.region and state.size.

> A: 

>> a. 

```{r}
incomes <- state.x77[,2] 
incomesf <- factor(state.region)

tapplyCount <- tapply(X = incomes,
                      INDEX = incomesf, 
                      FUN = mean)
tapplyCount

aggCount <- aggregate(x = incomes, 
          by = list(incomesf), 
          FUN = mean)

aggCount
```

>> b. 

```{r}
illit <- state.x77[,3] 
illitf <- factor(state.division)

tapplyCount <- tapply(X = illit,
                      INDEX = illitf, 
                      FUN = max)
tapplyCount
aggCount <- aggregate(x = illit, 
          by = list(illitf), 
          FUN = max)

aggCount
```

>> c. 

```{r}
states <- state.x77[,0]
statesf <- factor(state.region)

tapplyCount <- tapply(X = statesf,
                      INDEX = state.region, 
                      FUN = length)
tapplyCount

aggCount <- aggregate(x = state.region, 
          by = list(statesf), 
          FUN = length)

aggCount
```

>> d. 

```{r}
statesf <- factor(state.division)

tapplyCount <- tapply(X = statesf,
                      INDEX = state.division, 
                      FUN = length)
tapplyCount

aggCount <- aggregate(x = state.division, 
          by = list(statesf), 
          FUN = length)

aggCount
```

>> e. 

```{r}

```

\newpage
## Q2 
> Q: 

For a sample $x_1, x_2, ... , x_n$, the MAD estimator of scale is defined as
$1.4826 \cdot median\{|x_i - \bar{x} |\}$ were $\bar{x} =$ median$\{ x_i\}$

Use the matrix object mtcars to compute the MAD estimator of scale for the columns in mtcars

>> a. 

Using the apply() function with the mad() function

>> b. 

By calculating it directly from the definition (i.e., not using the mad() function). You may use the apply() and the sweep() functions but avoid using any loops

> A: 

>> a. 

```{r}
data(mtcars)

mad <- function(x) {
  median <- median(x, na.rm = TRUE)
  mad <- median(abs(x - median), na.rm = TRUE)  
  1.4826 * mad
}

madDf <- apply(X = mtcars,
                     MARGIN = 2,
                     FUN = mad)

madDf
```

>> b. 

```{r}
madDirect <- function(x) {
  median <- median(x, na.rm = TRUE)  
  deviations <- abs(sweep(x = as.matrix(x),
                          MARGIN = 2,
                          STATS = median)
                    )  
  mad <- median(deviations, na.rm = TRUE)  
  1.4826 * mad
}

madDdf <- apply(X = mtcars,
              MARGIN = 2,
              FUN = madDirect)

madDdf
```

\newpage
## Q3 
> Q: 

Let $h(x, n) = 1 + x + x^2 + ... + x^n = \sum\limits_{i=0}^{\infty}x^i$
Answer the following questiuons 

>> a. 

Write code to do the above in a for loop.

>> b. 

Rewrite the code that you wrote to use a while loop.

>> c. 

For each of the $x = 0.3, 1.01$ evaluate the performance for $n = 500, 5000$ in terms of time taken by the software. To do so, wrap the code around the R function system.time() with the same code as above inside the parentheses. Report the values returned in the output as per the user time field. 

>> d. 

Compare the above with results obtained avoiding loops.

> A: 

>> a. 

```{r}
x <- function(x, n) {
  result <- 0  # Initialize the result
  for (i in 0:n) {  # Loop from 0 to n (inclusive)
    result <- result + x^i  # Add x^i to the result
  }
  return(result)  # Return the computed sum
}
```

>> b. 

```{r}
y <- function(x, n) {
  result <- 0  # Initialize the result
  i <- 0  # Initialize the counter
  
  while (i <= n) {  # Loop while i is less than or equal to n
    result <- result + x^i  # Add x^i to the result
    i <- i + 1  # Increment the counter
  }
  
  return(result)  # Return the computed sum
}
```

>> c. 

$x = 0.3, 1.01$ evaluate the performance for $n = 500, 5000$

```{r}
x_value <- 0.3
n_value <- 500

system.time(expr = 
"sum_result <- x(x_value, n_value)
sum_result"
)

system.time(
"sum_result <- y(x_value, n_value)
sum_result"
)
```

```{r}
x_value <- 0.3
n_value <- 5000

system.time(expr = 
"sum_result <- x(x_value, n_value)
sum_result"
)

system.time(
"sum_result <- y(x_value, n_value)
sum_result"
)
```

```{r}
x_value <- 1.01
n_value <- 500

system.time(expr = 
"sum_result <- x(x_value, n_value)
sum_result"
)

system.time(
"sum_result <- y(x_value, n_value)
sum_result"
)
```

```{r}
x_value <- 1.01
n_value <- 5000

system.time(expr = 
"sum_result <- x(x_value, n_value)
sum_result"
)

system.time(
"sum_result <- y(x_value, n_value)
sum_result"
)
```

```{r}
# Define the function using a for loop
h_for <- function(x, n) {
  result <- 1  # Initialize the sum
  for (i in 1:n) {
    result <- result + x^i
  }
  return(result)
}

# Define the function using a while loop
h_while <- function(x, n) {
  result <- 1  # Initialize the sum
  i <- 1       # Start from the first power
  while (i <= n) {
    result <- result + x^i
    i <- i + 1
  }
  return(result)
}

# Set values of x and n
x_values <- c(0.3, 1.01)
n_values <- c(500, 5000)

# Loop through each combination of x and n, measuring time
results <- data.frame()

for (x in x_values) {
  for (n in n_values) {
    # Measure time for the for loop
    time_for <- system.time(h_for(x, n))["user.self"]
    
    # Measure time for the while loop
    time_while <- system.time(h_while(x, n))["user.self"]
    
    # Store the results
    results <- rbind(results, data.frame(x = x, n = n, Time_for = time_for, Time_while = time_while))
  }
}
```

```{r}
results
```

>> d. 

\newpage
## Q4 
> Q: 

The Lotka-Volterra model for a predator-prey system assumes that x(t) is the number of prey animals at the start of year t and that y(t) is the number of predators at the start of year t. Then the number of prey animals and predators at the end of the following year is given by: 

$$x (t + 1) = x(t) + b_xx(t) - d_xx(t)y(t)$$

$$y (t + 1) = y(t) + b_y d_x x(t)y(t) - d_yy(t)$$

Where $b_x$, $b_y$, $d_x$ and $d_y$ are as follows:
- $b_x$ is the natural birth rate of the prey animals in the absence of predation
- $d_x$ is the death rate of prey animal in an encounter with the predator.
- $d_y$ is the natural death rate of the predators in the absence of food (prey animals)
- $b_y$ is the efficiency of turning predated animals into predators

Let $b_x = 0.04$, $d_x = 0.0005$, $b_y = 0.1$, and $d_y = 0.2$.

Suppose that there were 4000 animal of the prey variety at the beginning of the time period. Also, suppose that there were only 100 predators. Write a while loop to show the predator-prey system as long as there are over 3900 prey animals. Save the prey/predator output in a list and plot them using lines on the same plot. 

> A: 

```{r}
bx <- 0.04  
dx <- 0.0005  
by <- 0.1  
dy <- 0.2  

prey <- 4000  
predator <- 100 

preyList <- c(prey)
predatorList <- c(predator)

while (prey > 3900) {
  newPrey <- prey + bx * prey - dx * prey * predator
  newPredator <- predator + by * dx * prey * predator - dy * predator
  # this is a lot like recursion, which
  # is a lot like recursion, which
  # is a lot like...
  preyList <- c(preyList, newPrey)
  predatorList <- c(predatorList, newPredator)
  
  prey <- newPrey
  predator <- newPredator
}
```

```{r}
plot(preyList, 
     type="l", 
     col="cyan3", 
     ylim=c(min(c(preyList, predatorList)), max(c(preyList, predatorList))),
     xlab="Years", 
     ylab="Animals",
     main="Lotka-Volterra model")
lines(predatorList, 
      col="tan3")
legend("right", 
       inset=0,
       legend=c("Prey Count", "Predator Count"), 
       col=c("cyan3", "tan3"), 
       lty=1)
```

\newpage
## Q5 
> Q: 

The game of craps is played as follows: first, Player 1 rolls two six-sided die; let x be the sum of the die on the first roll. If x = 7 or x = 11, then Player 1 wins, otherwise the player continues rolling until (s)he gets x again, in which case also Player 1 wins, or until (s)he gets 7 or 11, in which case (s)he loses. Write R code to simulate the game of craps. You can simulate the roll of a fair die using the sample() function in R.

> A: 

```{r, echo=FALSE, fig.cap="Saw what I did there?", out.width = '100%'}
knitr::include_graphics("sawIt.jpg")
```

```{r}
ohCrap <- function() {
  roll1 <- sum(sample(1:6, 2, replace = TRUE))
  if (roll1 == 7 || roll1 == 11) {
    return("Player 1 wins on the first roll!")
  } else {
    point <- roll1
    repeat {
      rollN <- sum(sample(1:6, 2, replace = TRUE))
      if (rollN == point) {
        return("Player 1 wins!")
      }
      if (rollN == 7 || rollN == 11) {
        return("Player 1 loses!")
      }
    }
  }
}

print("Let's play a game!")
rep(ohCrap(), 10)
```

Orange you glad I went with the (jig)Saw joke instead of a poop joke? 

\newpage
## Q6
> Q: 

Suppose that $(x(t), y(t))$ has polar coordinates given by $(\sqrt{t}, 2\pi t)$. Write code to plot the curve $(x(t), y(t))$ for $t \in [0,1].$

> A: 

Polar to Cartesian coordinates, r radius 
x = r cos $\theta$
y = r sin $\theta$

Where $r = \sqrt{t}$
Add $\theta = 2 \pi t$

Utilizing this conversion, we then have: 

$x(t) = \sqrt{t} \cdot \cos(2\pi t)$
$y(t) = \sqrt{t} \cdot \sin(2\pi t)$

```{r}
t <- seq(from = 0, to = 1, by = 0.001)

# xt <- sqrt(t)
# yt <- 2 * pi * t

xt <- sqrt(t) * cos(2 * pi * t)
yt <- sqrt(t) * sin(2 * pi * t)

plot(x = xt, 
     y = yt, 
     type = "l",
     main = "Look, A Spiral!")
```
Here's a for loop of it. 

```{r}
t <- seq(from = 0, to = 1, by = 0.001)

xt <- numeric(length(t))
yt <- numeric(length(t))

for (i in 1:length(t)) {
  xt[i] <- sqrt(t[i]) * cos(2 * pi * t[i])
  yt[i] <- sqrt(t[i]) * sin(2 * pi * t[i])
}

plot(x = xt, 
     y = yt, 
     type = "l",
     main = "Look, A Spiral, Again!")
```

\newpage
## Q7 
> Q: 

Consider the following code: 

```{r}
x <- matrix(rnorm(n = 500), ncol = 5)
varx <- var(x)
```

Starting with varx, use two applications of the sweep() function, one dividing each row of the matrix and the other dividing each column, of a covariance matrix to obtain R, the correlation matrix. 

> A: 

```{r}
# start
x <- matrix(rnorm(n = 500), ncol = 5)
varx <- var(x)

# the problem
std_devs <- sqrt(diag(varx))

rowSweep <- sweep(x = varx,
                  MARGIN = 1,
                  STATS = std_devs, 
                  FUN = "/")

# 5x5 matrix 
corR <- sweep(x = rowSweep, 
              MARGIN = 2, 
              STATS = std_devs, 
              FUN = "/")
corR
```