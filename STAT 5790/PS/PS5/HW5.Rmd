---
title: "HW5"
output:
  pdf_document: default
  html_document: default
  word_document: default
date: "2024-09-29"
---

# Status 
  - Q1: 
  - Q2: WIP 
  - Q3: WIP
  - Q4: WIP
  - Q5: WIP 
  - Q6: ISH 
  - Q7: WIP 

# Homework 5
Due October 15 

## Q1 
> Q: 

Use the state.x77 data matrix and the tapply(), and separately, the aggregate() function to obtain

>> a. 

The mean per capita income of the states in each of the four regions defined by the factor state.region,

>> b.

The maximum illiteracy rates for states in each of the nine divisions defined by the factor state.division,

>> c. 

The number of states in each region,

>> d.

The names of the states in each division,

>> e. 

The median high school graduation rates for groups of states defined by combinations of the factors
state.region and state.size.

> A: 

>> a. 

>> b. 

>> c. 

>> d. 

>> e. 

\newpage
## Q2 
> Q: 

For a sample $x_1, x_2, ... , x_n$, the MAD estimator of scale is defined as
$1.4826 \cdot median\{|x_i - \bar{x} |\}$ were $\bar{x} =$ median$\{ x_i\}$

Use the matrix object mtcars to compute the MAD estimator of scale for the columns in mtcars

>> a. 

Using the apply() function with the mad() function

>> b. 

By calculating it directly from the definition (i.e., not using the mad() function). You may use the apply() and the sweep() functions but avoid using any loops

> A: 

>> a. 

```{r}
# Load the mtcars dataset
data(mtcars)

# Define a custom function to compute the MAD estimator of scale
mad_estimator <- function(column) {
  median_value <- median(column, na.rm = TRUE)  # Median of the column
  mad_value <- median(abs(column - median_value), na.rm = TRUE)  # MAD
  return(1.4826 * mad_value)  # MAD estimator
}

# Apply the custom function to each column in mtcars
mad_results <- apply(mtcars, 2, mad_estimator)

# Display the MAD estimator of scale for each column
print(mad_results)
```

>> b. 

```{r}
# Load the mtcars dataset
data(mtcars)

# Define a function to compute the MAD estimator of scale directly
mad_estimator_direct <- function(column) {
  median_value <- median(column, na.rm = TRUE)  # Calculate the median
  abs_deviations <- abs(sweep(as.matrix(column), 2, median_value))  # Compute absolute deviations from the median
  mad_value <- median(abs_deviations, na.rm = TRUE)  # Median of absolute deviations
  return(1.4826 * mad_value)  # Return the MAD estimator
}

# Apply the function to each column in mtcars
mad_results_direct <- apply(mtcars, 2, mad_estimator_direct)

# Display the MAD estimator of scale for each column
print(mad_results_direct)
```

\newpage
## Q3 
> Q: 

Let $h(x, n) = 1 + x + x^2 + ... + x^n = \sum\limits_{i=0}^{\infty}x^i$
Answer the following questiuons 

>> a. 

Write code to do the above in a for loop.

>> b. 

Rewrite the code that you wrote to use a while loop.

>> c. 

For each of the $x = 0.3, 1.01$ evaluate the performance for $n = 500, 5000$ in terms of time taken by the software. To do so, wrap the code around the R function system.time() with the same code as above inside the parentheses. Report the values returned in the output as per the user time field. 

>> d. 

Compare the above with results obtained avoiding loops.

> A: 

>> a. 

```{r}
x <- function(x, n) {
  result <- 0  # Initialize the result
  for (i in 0:n) {  # Loop from 0 to n (inclusive)
    result <- result + x^i  # Add x^i to the result
  }
  return(result)  # Return the computed sum
}
```

>> b. 

```{r}
y <- function(x, n) {
  result <- 0  # Initialize the result
  i <- 0  # Initialize the counter
  
  while (i <= n) {  # Loop while i is less than or equal to n
    result <- result + x^i  # Add x^i to the result
    i <- i + 1  # Increment the counter
  }
  
  return(result)  # Return the computed sum
}
```

>> c. 

$x = 0.3, 1.01$ evaluate the performance for $n = 500, 5000$

```{r}
x_value <- 0.3
n_value <- 500

system.time(expr = 
"sum_result <- x(x_value, n_value)
sum_result"
)

system.time(
"sum_result <- y(x_value, n_value)
sum_result"
)
```

```{r}
x_value <- 0.3
n_value <- 5000

system.time(expr = 
"sum_result <- x(x_value, n_value)
sum_result"
)

system.time(
"sum_result <- y(x_value, n_value)
sum_result"
)
```

```{r}
x_value <- 1.01
n_value <- 500

system.time(expr = 
"sum_result <- x(x_value, n_value)
sum_result"
)

system.time(
"sum_result <- y(x_value, n_value)
sum_result"
)
```

```{r}
x_value <- 1.01
n_value <- 5000

system.time(expr = 
"sum_result <- x(x_value, n_value)
sum_result"
)

system.time(
"sum_result <- y(x_value, n_value)
sum_result"
)
```

```{r}
# Define the function using a for loop
h_for <- function(x, n) {
  result <- 1  # Initialize the sum
  for (i in 1:n) {
    result <- result + x^i
  }
  return(result)
}

# Define the function using a while loop
h_while <- function(x, n) {
  result <- 1  # Initialize the sum
  i <- 1       # Start from the first power
  while (i <= n) {
    result <- result + x^i
    i <- i + 1
  }
  return(result)
}

# Set values of x and n
x_values <- c(0.3, 1.01)
n_values <- c(500, 5000)

# Loop through each combination of x and n, measuring time
results <- data.frame()

for (x in x_values) {
  for (n in n_values) {
    # Measure time for the for loop
    time_for <- system.time(h_for(x, n))["user.self"]
    
    # Measure time for the while loop
    time_while <- system.time(h_while(x, n))["user.self"]
    
    # Store the results
    results <- rbind(results, data.frame(x = x, n = n, Time_for = time_for, Time_while = time_while))
  }
}
```

```{r}
results
```

>> d. 

\newpage
## Q4 
> Q: 

The Lotka-Volterra model for a predator-prey system assumes that x(t) is the number of prey animals at the start of year t and that y(t) is the number of predators at the start of year t. Then the number of prey animals and predators at the end of the following year is given by: 

$$x (t + 1) = x(t) + b_xx(t) - d_xx(t)y(t)$$

$$y (t + 1) = y(t) + b_y d_x x(t)y(t) - d_yy(t)$$

Where $b_x$, $b_y$, $d_x$ and $d_y$ are as follows:
- $b_x$ is the natural birth rate of the prey animals in the absence of predation
- $d_x$ is the death rate of prey animal in an encounter with the predator.
- $d_y$ is the natural death rate of the predators in the absence of food (prey animals)
- $b_y$ is the efficiency of turning predated animals into predators

Let $b_x = 0.04$, $d_x = 0.0005$, $b_y = 0.1$, and $d_y = 0.2$.

Suppose that there were 4000 animal of the prey variety at the beginning of the time period. Also, suppose that there were only 100 predators. Write a while loop to show the predator-prey system as long as there are over 3900 prey animals. Save the prey/predator output in a list and plot them using lines on the same plot. 

> A: 

```{r}
# Set initial parameters
bx <- 0.04  # Natural birth rate of prey
dx <- 0.0005  # Death rate of prey in an encounter with predator
by <- 0.1  # Efficiency of turning predated animals into predators
dy <- 0.2  # Natural death rate of predators

# Initial conditions
prey <- 4000  # Initial number of prey
predator <- 100  # Initial number of predators

# Create lists to store prey and predator values over time
prey_list <- c(prey)
predator_list <- c(predator)

# While loop to simulate the predator-prey system
while (prey > 3900) {
  # Update prey and predator populations using Lotka-Volterra model
  new_prey <- prey + bx * prey - dx * prey * predator
  new_predator <- predator + by * dx * prey * predator - dy * predator
  
  # Append the new populations to the lists
  prey_list <- c(prey_list, new_prey)
  predator_list <- c(predator_list, new_predator)
  
  # Update the current prey and predator populations for the next iteration
  prey <- new_prey
  predator <- new_predator
}

# Plot the results
plot(prey_list, type="l", col="blue", ylim=c(min(c(prey_list, predator_list)), max(c(prey_list, predator_list))),
     xlab="Time (years)", ylab="Population", main="Predator-Prey System")
lines(predator_list, col="red")
legend("topright", legend=c("Prey Population", "Predator Population"), col=c("blue", "red"), lty=1)
```

\newpage
## Q5 
> Q: 

The game of craps is played as follows: first, Player 1 rolls two six-sided die; let x be the sum of the die on the first roll. If x = 7 or x = 11, then Player 1 wins, otherwise the player continues rolling until (s)he gets x again, in which case also Player 1 wins, or until (s)he gets 7 or 11, in which case (s)he loses. Write R code to simulate the game of craps. You can simulate the roll of a fair die using the sample() function in R.

> A: 

```{r}
# Function to simulate a game of craps
play_craps <- function() {
  # Roll two dice and sum the result
  first_roll <- sum(sample(1:6, 2, replace = TRUE))
  
  # Check if the player wins on the first roll
  if (first_roll == 7 || first_roll == 11) {
    return("Player 1 wins on the first roll!")
  } else {
    # Continue rolling until player gets the first roll value or 7 or 11
    point <- first_roll
    repeat {
      roll <- sum(sample(1:6, 2, replace = TRUE))
      
      # If player rolls the point value again, they win
      if (roll == point) {
        return("Player 1 wins!")
      }
      
      # If player rolls a 7 or 11, they lose
      if (roll == 7 || roll == 11) {
        return("Player 1 loses!")
      }
    }
  }
}

# Simulate the game
result <- play_craps()
print(result)
```

\newpage
## Q6
> Q: 

Suppose that $(x(t), y(t))$ has polar coordinates given by $(\sqrt{t}, 2\pi t)$. Write code to plot the curve $(x(t), y(t))$ for $t \in [0,1].$

> A: 

Polar to Cartesian coordinates, r radius 
x = r cos $\theta$
y = r sin $\theta$

$x(t) = \sqrt{t} \cdot \cos(2\pi t)$
$y(t) = \sqrt{t} \cdot \sin(2\pi t)$

```{r}
t <- seq(from = 0, to = 1, by = 0.001)

# xt <- sqrt(t)
# yt <- 2 * pi * t

xt <- sqrt(t) * cos(2 * pi * t)
yt <- sqrt(t) * sin(2 * pi * t)

plot(x = xt, 
     y = yt, 
     type = "l")
```

```{r}
# Define the time sequence
t <- seq(from = 0, to = 1, by = 0.001)

# Initialize vectors for xt and yt
xt <- numeric(length(t))
yt <- numeric(length(t))

# For loop to calculate xt and yt at each time point
for (i in 1:length(t)) {
  xt[i] <- sqrt(t[i]) * cos(2 * pi * t[i])
  yt[i] <- sqrt(t[i]) * sin(2 * pi * t[i])
}

# Plot the results
plot(x = xt, 
     y = yt, 
     type = "l")
```

\newpage
## Q7 
> Q: 

Consider the following code: 

```{r}
x <- matrix(rnorm(n = 500), ncol = 5)
varx <- var(x)
```

Starting with varx, use two applications of the sweep() function, one dividing each row of the matrix and the other dividing each column, of a covariance matrix to obtain R, the correlation matrix. 

> A: 

```{r}
# Generate the matrix x
x <- matrix(rnorm(n = 500), ncol = 5)

# Calculate the covariance matrix varx
varx <- var(x)

# Step 1: Extract the standard deviations (square root of the diagonal of varx)
std_devs <- sqrt(diag(varx))

# Step 2: Use sweep to divide each row by the corresponding standard deviation
varx_sweep_row <- sweep(varx, 1, std_devs, FUN = "/")

# Step 3: Use sweep to divide each column by the corresponding standard deviation
R <- sweep(varx_sweep_row, 2, std_devs, FUN = "/")

# Print the correlation matrix R
print(R)
```