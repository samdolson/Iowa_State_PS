---
title: "PS6"
output: pdf_document
date: "2024-10-20"
---

# Q1 

Vibrothermography is a modern nondestructive evaluation imaging technique for detecting cracks or flaws
in industrial, dental and aerospace applications. The imaging modality works on the principle that a sonic or ultrasonic energy pulse when applied to a unit being tested causes it to vibrate. As a result, it is expected that the faces of a crack will rub against each other, resulting in an increase in temperature in that region. An infrared camera captures this increased temperature and produces a sequence of images of the temperature intensities over a short period of time starting just before the pulse of energy is applied and ending around the time that generated heat has dissipated. A sequence of images records the temperature changes over time. The primary objective of this technology is to detect flaws in the material with a high degree of precision. If the crack is larger than a certain threshold, the part needs to be taken out of operation and repaired or replaced. 

The file etcpod 05-400 102307 1 trig01.dat, on measurements made on an aircraft engine part, and available at the class datasets site on Canvas is three-dimensional with 72 × 72 × 150 elements, and each element representing the temperature intensity at that pixel and time-point. Thus there are 150 frames, each of 72 × 72 pixels.

## (a) 

Read in the dataset and store in an appropriate array. Note that this is simply a file of numeric values in ASCII format.

```{r}
dat <- read.table("C:/Users/samue/OneDrive/Desktop/Iowa_State_PS/STAT 5790/PS/PS6/etcpod_05-400_102307_1_trig01.dat")

dat <- as.matrix(dat)

arrayDat <- array(dat, dim = c(72, 72, 150))

dim(arrayDat)
```

## (b) 

One way to decide on where there is an indication or a flaw in the material is to determine whether there is a hotspot in the image and whether the high temperature elevation is significant enough to warrant further action. However, there are complications. We will not address all of them now, but only some of them in a simplified and idealized setting.

### i. 

Estimation of background noise. Materials with large grains are noisy (and generate temperatures with widely varying intensities) so we may try to reduce this effect by (crudely) estimating and eliminating the background from each frame. We do so by creating a frame of average intensities from the first five frames (when the sonic or high energy pulse has not been ramped up substantially. Use matrix and array operations and functions to obtain this averaged image.

```{r}
# Extract the first five frames
firstFive <- arrayDat[ , , 1:5]

# Compute the average across these first five frames
averageFrames <- apply(
  X = firstFive,
  MARGIN = c(1, 2), 
  FUN = mean)

image(averageFrames)

image(x= 1:72, 
      y = 1:72, 
      averageFrames[, 72:1]
      )
```

### ii. 

Elimination of background noise. In the next step, we will substract the background from each of the 150 frames. Perform this operation using the background estimate obtained from the previous part.

```{r}
backgroundRep <- array(rep(averageFrames, times = 150), 
                       dim = c(72, 72, 150)
                       )

arrayDatSub <- arrayDat - backgroundRep
```

### iii. 

Identifying frame with hottest signal. Our next objective is to identify the frame in the sequence with the hottest intensity pixel. Using matrix and apply operations, find this frame.

```{r}
maxPerFrame <- apply(X = arrayDatSub, 
                     MARGIN = 3, 
                     FUN = max)

hottestInd <- which.max(maxPerFrame)
hottestVal <- max(maxPerFrame)

hottestInd
hottestVal
```

### iv. 

Actually, the operation in the previous part is a bit too simplified. To guard against spurious spikes, a smoothing averaging is applied. In other words, for each pixel indexed by (i, j) the values of the pixels indexed by (i-1, j),(i, j-1),(i+1, j),(i, j+1) and (i, j) are averaged and the hottest frame is picked from the one with the highest neighborhood-averaged intensity. Use array techniques to pick out this hottest frame. (Hint: Consider adding another dimension to your 3-d array, and also expanding the frames by one pixel at each edge ) 

```{r}
arrayDat_background_subtracted <- arrayDatSub

# 1. Expand the array by padding each frame with zeros (or replicate edge values if desired) for handling boundaries
pad_frame <- function(frame) {
  # Add one row/column of zeros on all sides (for 72x72 matrix)
  padded <- matrix(0, nrow = 74, ncol = 74)
  padded[2:73, 2:73] <- frame
  return(padded)
}

# Apply padding to all frames
padded_array <- array(0, dim = c(74, 74, 150))
for (k in 1:150) {
  padded_array[,,k] <- pad_frame(arrayDat_background_subtracted[,,k])
}

# 2. Perform smoothing (neighborhood averaging) using the 5-point stencil for each pixel in the original 72x72 frames
smooth_frame <- function(padded_frame) {
  # Take the original frame (i.e., without the padding)
  smooth <- matrix(0, nrow = 72, ncol = 72)
  
  # Compute the average of the neighborhood pixels for each (i, j)
  for (i in 2:73) {
    for (j in 2:73) {
      smooth[i-1, j-1] <- mean(c(padded_frame[i, j],     # current pixel (i,j)
                                 padded_frame[i-1, j],   # pixel above (i-1,j)
                                 padded_frame[i+1, j],   # pixel below (i+1,j)
                                 padded_frame[i, j-1],   # pixel left (i,j-1)
                                 padded_frame[i, j+1]))  # pixel right (i,j+1)
    }
  }
  return(smooth)
}

# Apply the smoothing operation to each frame
smoothed_array <- array(0, dim = c(72, 72, 150))
for (k in 1:150) {
  smoothed_array[,,k] <- smooth_frame(padded_array[,,k])
}

# 3. Now find the maximum neighborhood-averaged intensity per frame
max_smoothed_intensity_per_frame <- apply(smoothed_array, 3, max)

# Identify the frame with the hottest smoothed intensity
hottest_frame_index <- which.max(max_smoothed_intensity_per_frame)

# hottest_frame_index is the index of the frame with the highest smoothed neighborhood intensity
hottest_smoothed_value <- max(max_smoothed_intensity_per_frame)
```

```{r}
pad_frame <- function(frame) {
  # Create a 74x74 matrix with zeros
  padded <- matrix(0, nrow = 74, ncol = 74)
  
  # Place the original 72x72 frame in the center
  padded[2:73, 2:73] <- frame
  
  return(padded)
}

# 2. Define a function to perform the smoothing for a single frame
smooth_frame <- function(padded_frame) {
  # Use vectorized operations to calculate the average of each pixel and its neighbors
  # Slice the padded frame for neighbors and compute the mean
  smoothed <- (padded_frame[2:73, 2:73] +  # center pixel
               padded_frame[1:72, 2:73] +  # top neighbor
               padded_frame[3:74, 2:73] +  # bottom neighbor
               padded_frame[2:73, 1:72] +  # left neighbor
               padded_frame[2:73, 3:74]) / 5  # right neighbor
  
  return(smoothed)
}

# 3. Apply padding and smoothing across all frames without using loops

# Use lapply to apply padding to all frames
padded_array <- lapply(1:dim(arrayDat_background_subtracted)[3], function(k) {
  pad_frame(arrayDat_background_subtracted[,,k])
})

# Use lapply again to smooth each padded frame
smoothed_array <- sapply(padded_array, function(padded_frame) {
  smooth_frame(padded_frame)
}, simplify = "array")

# 4. Find the hottest frame based on the smoothed intensities

# Find the maximum intensity in each smoothed frame
max_smoothed_intensity_per_frame <- apply(smoothed_array, 3, max)

# Identify the frame with the highest maximum intensity
hottest_frame_index <- which.max(max_smoothed_intensity_per_frame)
hottest_smoothed_value <- max(max_smoothed_intensity_per_frame)

# Output the hottest frame index and value
hottest_frame_index
hottest_smoothed_value
```

```{r}
hottest_frame_index
hottest_smoothed_value
```

### v. 

Display. Plot the resulting frame in the part (with or without extra credit above).

```{r}
hottestFrame <- arrayDat[ , , 93]

image(hottestFrame)

image(x= 1:72, 
      y = 1:72, 
      hottestFrame[, 72:1], 
      xlab = "", 
      ylab = "", 
      axes = FALSE
      )
```

\newpage

# Q2 

Complex materials development involves understanding the molecular structure of the material being tested and the movement of molecules under application of force. The dataset available in the Excel spreadsheet file PreliminaryData.xlsx on the class datasets site on Canvas was on measurements recorded by a former graduate student in Iowa State University’s Materials Science Engineering department. The observations are on several things but for this exercise, we will ignore most of them, but for the last two columns (which are measurements obtained by two methods) and the x- and y- coordinates.

## (a) 

Read in and store the dataset. Note that because this file was written in Excel which does not require formatting, there are three columns which are meaningless (and should be removed to conserve space).

```{r}
library(readxl)
PreliminaryData <- read_excel("C:/Users/samue/OneDrive/Desktop/Iowa_State_PS/STAT 5790/PS/PS6/PreliminaryData.xlsx") 

cleanPrelim <- PreliminaryData |> 
  # subset( , select = -c(8, 9, 11))
  subset( , select = c(5, 6, 10, 12))

names(cleanPrelim)
```

## (b) 

Data quality. The measurements in the last two columns are measurements on a grid. We will now investigate if every value in the x- and y coordinate is measured. (Note that both the x and y coordinates increment in terms of 10 units and start at 0.). An important aspect of this data quality check is to ascertain that every grid value is present. It would be helpful to know if the x- and the y-values are increasing in a nested sequence. Run checks to determine if this is indeed true.

```{r}
xObs <- unique(cleanPrelim$x)
yObs <- unique(cleanPrelim$y)

xExp <- seq(from = 0, to = max(cleanPrelim$x), by = 10)
yExp <- seq(from = 0, to = max(cleanPrelim$y), by = 10)

# xObs == xExp 
# yObs == yExp
```

## (c) 

For each of the (old and new) method measurements, we will create a matrix of the observed values (after scaling these down by 10), where the rows will correspond to x- and the columns will correspond to the y-coordinates (and the value of the measurement will be stored in the (x, y)th entry.) Do the above.

```{r}

```

## (d) 

For both sets of measurements, display the matrix in terms of an image.

```{r}

```